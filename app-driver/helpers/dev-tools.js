import S from "./singleton";

class DevTools {

   constructor() {
   }

   // this will capture allapi calls made by the client browser with 'api' in it
   static CaptureApiStart(urlPattern = '*api*') {
      // chrome devtools protocol (CDP) only works on chrome, firefox, and edge
      if (browser.capabilities.browserName.toString() !== 'chrome') {
         return;
      }

      let log = S.getConfig().log;
      let apiCalls = S.getConfig().apiCalls;
      apiCalls.length = 0;

      // enable api capture based on the urlPattern
      browser.cdp('Fetch', 'enable',
         {patterns: [{urlPattern: urlPattern, requestStage: 'Response'}]});

      browser.on('Fetch.requestPaused', (r) => {
         browser.cdp('Fetch', 'continueRequest', {'requestId': r.requestrId});
         apiCalls.push(r);
         log.info(`Devtools-Request: { url: ${r.request.url}, data: ${r.request.postData}, requestId: ${r.request}}`);
      });
   }

   static GetRequest(index, options = {postData: true}) {
      let apiCalls = S.getConfig().apiCalls;
      if (apiCalls.length === 0) {
         S.getConfig().log.info(`did you set the url pattern correctly?`);
         throw Error('NO API CALLS were captured.....');
      }
      let fullReq = apiCalls[index];
      let request = {};
      if (options.postData === true) {
         request = JSON.parse(fullReq.request.postData);
      }
      request.url = fullReq.request.url;
      request.method = fullReq.request.method;
      request.statusCode = fullReq.responseStatusCode;
      return request;
   }

   static CaptureApiEnd() {
      if (browser.capabilities.browserName.toString() !== 'chrome') {
         return;
      }
      browser.cdp('Fetch', 'disable');
      let apiCalls = S.getConfig().apiCalls;
      apiCalls.length = 0;
   }

   // this will add listeners to all events generated by chrome
   static AttachListeners(events, log) {
      // only attach to evetns if theis browser is chrome
      if (browser.capabilities.browserName.toString() !== 'chrome') {
         return;
      }

      browser.cdp('Log', 'enable');
      browser.on('Log.entryAdded', (logEntry) => {
         let eventEntry = `Log.entryAdded': source-> ${logEntry.entry.source}, level-> ${logEntry.entry.level},` +
            `text-> ${logEntry.entry.text}, url-> ${logEntry.entry.url}`;
         log.info(eventEntry);
         events.push(eventEntry);
      });

      browser.cdp('Runtime', 'enable');
      browser.on('Runtime.consoleAPICalled', (param) => {
         for (let i = 0; i < param.args.length; i++) {
            let eventEntry = `Runtime.consoleAPICalled': ${param.type} ${i + 1}-> ${param.args[i].value}`;
            log.info(eventEntry);
            events.push(eventEntry);
         }
      });
      browser.on('Runtime.exceptionThrown', (param) => {
         let eventEntry = `Runtime.exceptionThrown': ${param.exceptionDetails.text}`;
         log.info(eventEntry);
         events.push(eventEntry);
      });
      browser.on('Runtime.exceptionRevoked', (param) => {
         let eventEntry = `Runtime.exceptionRevoked': ${param.reason}`;
         log.info(eventEntry);
         events.push(eventEntry);
      });
   }

   // eslint-disable-next-line
   static DetachListeners(events, log) {
      browser.cdp('Log', 'disable');
      browser.cdp('Runtime', 'disable');
   }
}

export default DevTools;